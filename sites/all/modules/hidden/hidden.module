<?php
// $Id: hidden.module,v 1.8.2.1 2009/03/13 11:44:09 ekes Exp $

/**
 * @file
 * Module to create, track and display hidden content.
 */

// @todo descriptions of these
define('HIDDEN_LOG_DELETE', 1);
define('HIDDEN_LOG_HIDE', 2);
define('HIDDEN_LOG_UNHIDE', 3);
define('HIDDEN_LOG_REPORTED', 4);
define('HIDDEN_LOG_SEEN', 5);
define('HIDDEN_LOG_REASONS', 6);
define('HIDDEN_LOG_SPAM', 7);
define('HIDDEN_LOG_ERROR', 51);
define('HIDDEN_LOG_DEBUG_FILTER', 52);
define('HIDDEN_LOG_DEBUG', 53);

define('HIDDEN_MAIL_NEVER', 0);
define('HIDDEN_MAIL_NOW', 1);
define('HIDDEN_MAIL_LATER', 2);

define('HIDDEN_FILTER_PLAIN', 1);
define('HIDDEN_FILTER_PREG', 2);

define('HIDDEN_PAGER_LIMIT', 20);

/********************************************************************
 * Standard hooks
 */

 /**
 * Implementation of hook_boot().
 */
function hidden_boot() {
  if (module_exists('views')) {
    // @todo not yet D6
    //include_once drupal_get_path('module', 'hidden') .'/hidden.views.inc';
  }
}

/**
 * Implementation of hook_init().
 */
function hidden_init() {
  drupal_add_css(drupal_get_path('module', 'hidden') .'/hidden.css', 'module', 'all', FALSE);
}

/**
 * Implementation of hook_help().
 */
function hidden_help($path, $arg) {
  $output = '';

  switch ($path) {
    case 'admin/content/comment/list/hidden':
      $output = '<p>'. t('The following comments have been hidden.') .'</p>';
      break;
    case 'admin/content/comment/list/hiddenreported':
      $output = '<p>'. t('The following comments have been reported for hiding.') .'</p>';
    case 'admin/content/node/list/hidden':
      $output = '<p>'. t('The following nodes have been hidden.') .'</p>';
      break;
    case 'admin/content/node/list/hiddenreported':
      $output = '<p>'. t('The following nodes have been reported for hiding.') .'</p>';
      break;
    case 'admin/content/hidden':
    case 'admin/content/hidden/reasons':
      $output = '<p>'. t('The default reasons offered for hiding an item. Disabled reasons do not show in the list.') .'</p>';
      break;
    case 'admin/content/hidden/reasons/edit':
      $output = '<p>'. t('Changing the text of a reason will change it for all previously hidden items as well.') .'</p>';
      break;
    case 'admin/content/hidden/filters':
      $output = '<p>'. t('Custom filters to automate hiding of posts. If you set a time delay they will be hidden after that time when cron is run.') .'</p>';
      break;
    case 'admin/settings/hidden':
      $output = '<p>'. t('How much detail to log and send in any e-mails. Hide reports can be sent immediately or saved and sent together in one e-mail periodically.') .'</p>';
      break;
    case 'admin/help#hidden':
      $output = '<p>'. t('Hidden enables you to un-/hide nodes and comments.') ."</p>\n".
        '<p>'. t("Every node or comment has a link called 'hide' (or 'unhide' if hidden).") ."</p>\n".
        '<p>'. t("To 'hide':") ."<br />\n".
        '- '. t('Click the link.') ."<br />\n".
        '- '. t('On the following page you have to supply a reason why the item will be hidden before you submit the form.') ."</p>\n".
        '<p>'. t('Hidden items should not appear in any listings for non-admin users except under hidden/.') ."</p>\n".
        '<p>'. t("To 'unhide':") ."<br />\n".
        '- '. t("Click the link after the contents' title/subject or click on the contents' title/subject.") ."<br />\n".
        '- '. t("Then click 'unhide'.") ."</p>\n";
      break;
    }

    return $output;
}

/**
 * Implementation of hook_perm().
 */
function hidden_perm() {
  return array('access hidden', 'report for hiding', 'mark as hidden', 'administer hidden', 'bypass hidden filter');
}

/**
 * Implementation of hook_theme().
 */
function hidden_theme() {
  return array(
    'hidden_admin_settings' => array(
      'arguments' => array(
        'form' => NULL,
        ),
      ),
    'hidden_link' => array(
      'arguments' => array(
        'links' => NULL,
        ),
      ),
    'hidden_list_nodes' => array(
      'arguments' => array(
        'table' => NULL,
        ),
      ),
    'hidden_list_admin_nodes' => array(
      'arguments' => array(
        'form' => NULL,
        ),
      ),
    'hidden_list_admin_nodes_reported' => array(
      'arguments' => array(
        'form' => NULL,
        ),
      ),
    'hidden_list_comments' => array(
      'arguments' => array(
        'table' => NULL,
        ),
      ),
    'hidden_list_admin_comments' => array(
      'arguments' => array(
        'form' => NULL,
        ),
      ),
    'hidden_list_admin_comments_reported' => array(
      'arguments' => array(
        'form' => NULL,
        ),
      ),
    'hidden_view_reason' => array(
      'arguments' => array(
        'title' => NULL,
        'public' => '',
        'description' => '',
        'private' => '',
        'content' => '',
        'view' => TRUE,
        ),
      ),
    'hidden_filters_admin_enabled_form' => array(
      'arguments' => array(
        'form' => NULL,
        ),
    )
  );
}

/**
 * Implementation of hook_menu().
 */
function hidden_menu() {
  $items = array();
  $view = array('access hidden');
  $report = array('report for hiding');
  $hide = array('mark as hidden');
  $admin = array('administer hidden');

  $items['admin/settings/hidden'] = array(
    'title' => 'Hidden settings',
    'description' => 'Administer settings for the hidden module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_admin_settings'),
    'access arguments' => $admin,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden'] = array(
    'title' => 'Hidden reasons and filters',
    'description' => 'Manage reasons for hiding and content filters',
    'page callback' => 'hidden_reasons_admin',
    'access arguments' =>  $admin,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/reasons'] = array(
    'title' => 'Reasons',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/content/hidden/reasons/add'] = array(
    'title' => 'Add hidden reason',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_reasons_admin_form', 'add'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/reasons/edit'] = array(
    'title' => 'Edit hidden reason',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_reasons_admin_form', 'edit'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/reasons/enable'] = array(
    'title' => 'Enable hidden reason',
    'page callback' => 'hidden_reasons_admin_able',
    'page arguments' => array('enable'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/reasons/disable'] = array(
    'title' => 'Disable hidden reason',
    'page callback' => 'hidden_reasons_admin_able',
    'page arguments' => array('disable'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/filters'] = array(
    'title' => 'Filters',
    'description' => 'Manage filters for hidden content',
    'page callback' => 'hidden_filters_admin',
    'access arguments' => $admin,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/filters/add'] = array(
    'title' => 'Add filter',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_filters_admin_form', 'add'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/filters/edit'] = array(
    'title' => 'Edit filter',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_filters_admin_form', 'edit'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/filters/enable'] = array(
    'title' => 'Enable filter',
    'page callback' => 'hidden_filters_admin_able',
    'page arguments' => array('enable'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/hidden/filters/disable'] = array(
    'title' => 'Disable filter',
    'page callback' => 'hidden_filters_admin_able',
    'page arguments' => array('disable'),
    'access arguments' => $admin,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.admin.inc',
  );
  $items['admin/content/comment/list/hidden'] = array(
    'title' => 'Hidden',
    'description' => 'Hidden comments',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_list_admin_comments'),
    'access arguments' => $hide,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hidden.display-admin.inc'
  );
  $items['admin/content/comment/list/hiddenreported'] = array(
    'title' => 'Reported',
    'description' => 'Reported comments',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_list_admin_comments_reported'),
    'access arguments' => $hide,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hidden.display-admin.inc',
  );
  $items['admin/content/node/list/hidden'] = array(
    'title' => 'Hidden',
    'description' => 'Hidden nodes',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_list_admin_nodes'),
    'access arguments' => $hide,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hidden.display-admin.inc',
  );
  $items['admin/content/node/list/hiddenreported'] = array(
    'title' => 'Reported',
    'description' => 'Reported nodes',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_list_admin_nodes_reported'),
    'access arguments' => $hide,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hidden.display-admin.inc',
  );

  $items['hidden'] = array(
    'title' => 'Hidden',
    'description' => 'Access hidden content',
    'page callback' => 'hidden_list_nodes',
    'access arguments' => $view,
  //      'type' => MENU_SUGGESTED_ITEM,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'hidden.display-pages.inc',
  );
  $items['hidden/node'] = array(
    'title' => 'Hidden nodes',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['hidden/comment'] = array(
    'title' => 'Hidden comments',
    'page callback' => 'hidden_list_comments',
    'access arguments' => $view,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hidden.display-pages.inc',
  );
  $items["hidden/%/%"] = array(
    'title' => 'view',
    'page callback' => 'hidden_view',
    'page arguments' => array(1, 2),
    'access arguments' =>  $view,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.display-pages.inc',
  );

  $items['hidden/%/%/hide'] = array(
    'title' => 'Report post',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_hide', 1, 2),
    'access arguments' => $hide,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.action-pages.inc',
  );
  $items['hidden/%/%/report'] = array(
    'title' => 'Report post',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_report', 1, 2),
    'access arguments' => $report,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.action-pages.inc',
  );
  $items['hidden/%/%/unhide'] = array(
    'title' => 'Don\'t hide',
    'page callback' => 'hidden_unhide',
    'page arguments' => array(1, 2),
    'access arguments' => $hide,
    'type' => MENU_CALLBACK,
    'file' => 'hidden.action-pages.inc',
  );

  return $items;
}


/**
 * Implementation of hook_cron().
 *
 * sends periodic e-mails reports for actions set to HIDDEN_MAIL_LATER
 * unpublishes content marked as delayed hidden
 */
function hidden_cron() {
  $now = time();
  $email = _hidden_settings_mail();
  if ($email['domail'] == TRUE) {
    if (variable_get('hidden_mail_sent', 0) + $email['frequency'] < $now) {
      // log emailing on, hidden mail not sent since frequency reached
      $message = '';
      foreach ($email as $type => $when) {
        if ($when['when'] == HIDDEN_MAIL_LATER) {
          // $email set action to be mailed later
          $query = 'SELECT * FROM {hidden_log} WHERE action=%d';
          if (! $result = db_query($query, $type)) {
            _hidden_log(HIDDEN_LOG_ERROR, t('Error retrieving logged messages for e-mailing'));
            $error = TRUE;
          }
          else {
            while ($logged = db_fetch_object($result)) {
              // retrive additional information about each action that has happened
              $message .= _hidden_mail_cron_message($logged->action, $logged->description, unserialize($logged->ids), $logged->uid);
            }
          }
        }
      }
      if ($message != '') {
        // send out e-mail
        if (_hidden_mail(t('Collected log messages'), $message) && !$error) {
          $query = 'DELETE FROM {hidden_log} WHERE hidetime < %d';
          if (! db_query($query, $now)) {
            _hidden_log(HIDDEN_LOG_ERROR, t('Error removing sent logged messages from database'));
          }
          else {
            variable_set(hidden_mail_sent, $now);
          }
        }
        else {
          _hidden_log(HIDDEN_LOG_DEBUG, 'Logged messages left in database because of error retrieving or sending');
        }
      }
    }
  }
  // unpublish delayed hides
  // TODO if filter settings delayed filters
  foreach (array('node', 'comment') as $type) {
    $query = "SELECT * FROM {hidden_$type} WHERE delay != 0 AND delay < %d";
    $result = db_query($query, time());
    while ($hidden = db_fetch_object($result)) {
      _hidden_hidden_hide_unpublish($type, ($type == 'node') ? $hidden->nid : $hidden->cid);
      $query = "UPDATE {hidden_$hidden} SET delay=0 WHERE hid=%d";
      db_query($query, $hidden->hid);
      _hidden_log(HIDDEN_LOG_HIDE, t('Hidden %type', array('%type' => $type)), $type,
                  ($type == 'node') ? $hidden->nid : $hidden->cid,
                  $hidden->rid, $hidden->publicnote, $hidden->privatenote, $hidden->uid);
    }
  }
}

/**
 * Implementation of hook_comment().
 *
 * adds reasons and div tags to viewed comments.
 * passes comment through any filters.
 * removes deleted or published comments from the hidden records.
 */
function hidden_comment(&$comment, $action) {
  switch ($action) {
    case 'view':
      if (isset($comment->status) && $comment->status == COMMENT_NOT_PUBLISHED) {
        // all hidden comments are unpublished so no point making unnecessary queries
        if ($hidden=_hidden_hidden_get('comment', $comment->cid)) {
          $title = check_plain($hidden->title);
          $public = check_markup($hidden->publicnote, FILTER_HTML_STRIP, FALSE);
          $description = check_markup($hidden->description, FILTER_HTML_STRIP, FALSE);
          $private = check_markup($hidden->privatenote, FILTER_HTML_STRIP, FALSE);
          $comment->comment = theme('hidden_view_reason', $title, $public, $description, $private, $comment->comment);
          $comment->subject = t('HIDDEN: @title', array('@title' => $comment->subject));
        }
      }
      break;
    case 'update':
      // TODO reinput if hidden
    case 'insert':
      if (user_access('bypass hidden filter')) {
        return;
      }
      // $comment an array here!
      hidden_filter_content($comment['subject'] .' '. $comment['comment'], 'comment', $comment['cid']);
      break;
    case 'publish':
      // @todo array, always?
      // what should happen here? filter?
      if (! hidden_hidden_check('comment', $comment['cid'])) {
        break;
      }
      break;
    case 'delete':
      if (_hidden_hidden_delete('comment', $comment->cid)) {
        if (db_affected_rows()>0) {
          if ($action == 'delete') {
            _hidden_log(HIDDEN_LOG_DELETE, t('Hidden comment deleted'));
          }
          else {
            _hidden_log(HIDDEN_LOG_UNHIDE, t('Hidden comment published'), 'comment', $comment->cid);
            drupal_set_message(t('Hidden comment published'));
          }
        }
      }
      else {
        _hidden_log(HIDDEN_LOG_ERROR, t('Error deleting hidden comment'), 'comment', $comment->cid);
      }
      break;
    case 'form':
      if ( hidden_hidden_check('comment', $comment->cid) && user_access('administer hidden')) {
        //TODO edit form
        return;
      }
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * adds reasons and div tags to viewed nodes.
 * passes node through any filters
 * removes deleted node from the records.
 */
function hidden_nodeapi(&$node, $action, $arg=0) {
  switch ($action) {
    case 'alter':
      if (! $node->status) {
        // all hidden nodes are unpublished so no point making unnecessary queries
        if ($hidden=_hidden_hidden_get('node', $node->nid)) {
          $title = check_plain($hidden->title);
          $public = check_markup($hidden->publicnote, FILTER_HTML_STRIP, FALSE);
          $description = check_markup($hidden->description, FILTER_HTML_STRIP, FALSE);
          $private = check_markup($hidden->privatenote, FILTER_HTML_STRIP, FALSE);
          // arg TRUE on teaser view
          $node->body = theme('hidden_view_reason', $title, $public, $description, $private, $node->body, !($arg));
          $node->title = t('HIDDEN: @title', array('@title' => $node->title));
            // sadly usually set by this point for nodes
        }
      }
      break;
    case 'update':
      if ($action=='update' && $node->status) {
        // node being updated and status is published check it wasn't hidden
        if (hidden_hidden_check('node', $node->nid)) {
          if (_hidden_hidden_delete('node', $node->nid)) {
            _hidden_log(HIDDEN_LOG_UNHIDE, t('Hidden node published.'), 'node', $node->nid);
            drupal_set_message(t('Hidden node published.'));
          }
          else {
            _hidden_log(HIDDEN_LOG_ERROR, t('Error unhiding publish node.'), 'node', $node->nid);
            drupal_set_message(t('Error unhiding published node.'), 'error');
          }
        }
      }
    case 'insert':
      if (user_access('bypass hidden filter')) {
        return;
      }
      hidden_filter_content($node->title .' '. $node->teaser .' '. $node->body, 'node', $node->nid);
      break;
    case 'delete':
      // comment_nodeapi doesn't call hook_comment delete but this query will delete comments too
      if (_hidden_hidden_delete('both', $node->nid)) {
        if (db_affected_rows()>0) {
          _hidden_log(HIDDEN_LOG_DELETE, t('Deleted hidden node and/or attached comments.'));
        }
      }
      else {
        _hidden_log(HIDDEN_LOG_ERROR, t('Error deleting hidden node and/or comments.'), 'node', $node->nid);
      }
  }
}

/**
 * Implementation of hook_node_operations().
 */
function hidden_node_operations() {
  $operations = array(
    'hide' => array(
      'label' => t('Hide'),
      'page callback' => 'hidden_operations_hide',
    ),
    'unhide' => array(
      'label' => t('Unhide'),
      'page callback' => 'hidden_operations_unhide',
    ),
  );

  return $operations;
}

/**
 * Implementation of hook_link().
 */
function hidden_link($type, $item = NULL, $teaser = FALSE) {
  $links = array();
  if (!$item) {
    return $links;
  }

  if ($type == 'comment') {
    $target = $item->cid;
    $iscomment = TRUE;
  }
  elseif ($type == 'node') {
    $target = $item->nid;
    $iscomment = FALSE;
  }
  else {
    return $links;
  }

  $hidden=_hidden_hidden_get($type, $target);

  if ($hidden == FALSE) {
    // not hidden
    if (user_access('mark as hidden')) {
      $links['hidden-hide'] = array(
        'title' => t('hide'),
        'href' => "hidden/$type/$target/hide",
        'query' => drupal_get_destination(),
        'fragment' => ($iscomment) ? "comment-$target" : '',
      );
    }
    // not hidden and is published
    if (user_access('report for hiding') && (
      ($type == 'comment' && $item->status != COMMENT_NOT_PUBLISHED) ||
        ($type == 'node' && $item->status)
    )) {
      $links['hidden-report'] = array(
        'title' => t('report'),
        'href' => "hidden/$type/$target/report",
        'query' => drupal_get_destination(),
        'fragment' => ($iscomment) ? "comment-$target" : '',
      );
    }
  }
  elseif ($hidden->delay!=0) {
    // marked to be hidden by a cron job
    if (user_access('mark as hidden')) {
      $links['hidden-hide'] = array(
        'title' => t('hide now'),
        'href' => "hidden/$type/$target/hide",
        'query' => drupal_get_destination(),
      );
      $links['hidden-unhide'] = array(
        'title' => t("don't hide"),
        'href' => "hidden/$type/$target/unhide",
        'query' => drupal_get_destination(),
      );
    }
    if (user_access('report for hiding')) {
      $links['hidden-report'] = array(
        'title' => t('report'),
        'href' => "hidden/$type/$target/report",
        'query' => drupal_get_destination(),
      );
    }
  }
  else {
    // hidden
    if (user_access('mark as hidden')) {
      $links['hidden-unhide'] = array(
        'title' => t('unhide'),
        'href' => "hidden/$type/$target/unhide",
      );
    }
  }

  return $links;
}

/**
 * Creates array of rows for hidden content tables.
 *
 * @param $query
 *   string sql query for the pager
 * @param $type
 *   string type of content (comment, node)
 * @return
 *   array of hidden content for theme_table()
 */
function _hidden_list_get($query, $type) {
  $result = pager_query($query, HIDDEN_PAGER_LIMIT);

  $rows = array();

  while ($links = db_fetch_object($result)) {
    if ($type == 'comment') {
      $target = 'comment/'. $links->cid;
    }
    else {
      $target = 'node/'. $links->nid;
    }

    $rows[] = array(
      l($links->title, 'hidden/'. $target),
      theme('username', $links),
      check_plain($links->reason),
    );

    if (count($rows)==0) {
      $rows[] = array(t('No hidden content'), '');
    }
  }

  return $rows;
}

/**
 * Creates pulldown box for admin list form mass unhide operation.
 *
 * @return
 *   form array
 */
function _hidden_list_admin_options() {
  // build an 'Update options' form
  $form['options'] = array(
    '#type' => 'fieldset', '#title' => t('Update options'),
    '#prefix' => '<div class="container-inline">', '#suffix' => '</div>'
  );

  $form['options']['operation']  = array(
    '#type' => 'select',
    '#options' => array('UNHIDE' => t('Unhide the selected posts')),
    '#description' => t(''),
  );

  $form['options']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update'),
  );

  return $form;
}

/**
 * Creates a pulldown for admin reported list form mass hide/seen operations.
 *
 * @return form array
 */
function _hidden_list_admin_reported_options() {
  // build an 'Update options' form
  $form['options'] = array(
    '#type' => 'fieldset', '#title' => t('Update options'),
    '#prefix' => '<div class="container-inline">', '#suffix' => '</div>'
  );

  $options = array('SEEN' => t('Mark the selected posts as seen'),
                   'HIDE' => t('Hide the selected posts'),
                  );
  if (module_exists('spam')) {
    $options['SPAM'] = t('Mark the selected posts as spam');
  }

  $form['options']['operation']  = array(
    '#type' => 'select',
    '#options' => $options,
    '#description' => t(''),
  );

  $form['options']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update'),
  );

  return $form;
}

/**
 * Formats reason for hiding in node and comment display.
 *
 * This is shown in all views of hidden nodes and comments, it's called from the
 * nodeapi('view') and comment('view') hooks.
 *
 * @param $title
 *   string plain text standard reason for hiding.
 * @param $public
 *   string html public note about hiding.
 * @param $description
 *   string html description of standard reason for hiding (optional).
 * @param $private
 *   string html private note about hiding (optional).
 * @param $content
 *   string html formated node/comment (optional).
 * @param $view
 *   bool FALSE if short display without additional info and content (for teaser view) (optional).
 * @return
 *   string formatted output
 * @ingroup themeable
 */
function theme_hidden_view_reason($title, $public, $description='', $private='', $content='', $view=TRUE) {
  $output = '<div class="hidden"><div class="reason">';
  $output .= t('<p>Hidden content:</p>');
  if ($title) {
    $output .= '<p>'. $title .'</p>';
    if ($view) {
      $output .= $description;
    }
  }
  $output .= $public;
  if (user_access('mark as hidden') && $view) {
    $output .= $private;
  }
  $output .= '</div>';
  if ($view) {
    $output .= $content;
  }
  $output .= '</div>';
  return $output;
}

/**
 * Admin node_operations() callback.
 */
function hidden_operations_hide($nids) {
  global $user;

  $hide = array();
  $error = array();
  foreach ($nids as $nid) {
    if (! hidden_hidden_check('node', $nid)) {
      $nid = (int)$nid;
      if (hidden_hidden_hide('node', $nid, $user->uid, 1)) {
        $hide[] = $nid;
      }
      else {
        $error[] = $nid;
      }
    }
  }
  if ($n = count($error)) {
    $msg = format_plural($n, 'Error hiding node.', 'Error hiding nodes.');
    _hidden_log(HIDDEN_LOG_ERROR, $msg, 'node', $error);
    drupal_set_message($msg, 'error');
  }
  if ($n = count($hide)) {
    $msg = format_plural($n, 'Hidden node.', 'Hidden nodes.');
    _hidden_log(HIDDEN_LOG_HIDE, $msg, 'node', $hide);
    drupal_set_message($msg);
  }

  drupal_goto('admin/content/node');
}

/**
 * Admin node_operations() callback.
 */
function hidden_operations_unhide($nids) {
  $unhide = array();
  $error = array();
  foreach ($nids as $nid) {
    $nid = (int)$nid;
    if (hidden_hidden_check('node', $nid)) {
      if (_hidden_hidden_unhide('node', $nid)) {
        $unhide[] = $nid;
      }
      else {
        $error[] = $nid;
      }
    }
  }
  if ($n = count($error)) {
    $msg = format_plural($n, 'Error unhiding node.', 'Error unhiding nodes.');
    _hidden_log(HIDDEN_LOG_ERROR, $msg, 'node', $error);
    drual_set_message($msg, 'error');
  }
  if ($n = count($unhide)) {
    $msg = format_plural($n, 'Unhidden node.', 'Unhidden nodes.');
    _hidden_log(HIDDEN_LOG_UNHIDE, $msg, 'node', $unhide);
    drupal_set_message($msg);
  }
}

/**
 * Checks if item is hidden.
 *
 * @param $type
 *   string content 'comment' or 'node'.
 * @param $id
 *   int cid or nid.
 * @return
 *   bool TRUE hidden FALSE not/fail.
 */
function hidden_hidden_check($type, $id) {
  static $hidden, $ltype, $lid, $count;
  if ($type == $ltype && $id == $lid) {
    return $hidden;
  }
  else {
    $ltype = $type;
    $lid = $id;
    $hidden = NULL;
  }

  if ($type != 'node' && $type != 'comment') {
    _hidden_log(HIDDEN_LOG_DEBUG, 'hidden_hidden_check() called with invalid $type');
    return FALSE;
  }
  $table = ($type == 'node') ? 'node' : 'comment';
  $col = ($type == 'node') ? 'nid' : 'cid';
  $query = "SELECT COUNT(*) FROM {hidden_$table WHERE $col = %d";

  $result = db_query($query, $id);
  if (db_result($result) != 0) {
    $hidden = TRUE;
    return TRUE;
  }
  else {
    $hidden = FALSE;
    return FALSE;
  }
}

/**
 * Gets a hidden item.
 *
 * @param $type
 *   string content type 'comment' or 'node'
 * @param $id
 *   int cid or nid
 * @return
 *   object -> hid, rid, title, description, publicnote, privatenote, or FALSE not hidden
 */
function _hidden_hidden_get($type, $id) {
  if ($type == 'node') {
    $query = 'SELECT h.hid, h.nid, h.rid, h.uid, h.publicnote, h.privatenote, h.delay,'.
            ' r.title, r.description'.
            " FROM {hidden_node} AS h".
            ' LEFT JOIN {hidden_reasons} AS r ON h.rid=r.rid'.
            " WHERE nid=%d";
  }
  elseif ($type == 'comment') {
    $query = 'SELECT h.hid, h.cid, h.rid, h.uid, h.publicnote, h.privatenote, h.delay,'.
            ' r.title, r.description'.
            " FROM {hidden_comment} AS h".
            ' LEFT JOIN {hidden_reasons} AS r ON h.rid=r.rid'.
            " WHERE cid=%d";
  }
  else {
    _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_hidden_get() called with invalid $type');
    $hidden = FALSE;
    return $hidden;
  }

  if ($result = db_query($query, $id)) {
    if ($hidden = db_fetch_object($result)) {
      $hidden->type = $type;
      $hidden->id = $id;
      return $hidden;
    }
    else {
      $hidden = FALSE;
      return $hidden;
    }
  }
}

/**
 * Removes hidden items from table.
 *
 * @param $type
 *   string content type to remove 'comment', 'node' or 'both'.
 * @param $id
 *   int cid (comment only) or nid (node only or both).
 * @return
 *   FALSE on fail.
 */
function _hidden_hidden_delete($type, $id) {

  if ($type == 'both' || $type == 'node') {
    $query = 'DELETE FROM {hidden_node} WHERE nid=%d';
    // error catching
    if (! db_query($query, $id)) {
      return FALSE;
    }
  }

  if ($type == 'comment') {
    $query = 'DELETE FROM {hidden_comment} WHERE cid=%d';
  }
  elseif ($type == 'both') {
    $query = 'DELETE FROM {hidden_comment} WHERE nid=%d';
  }
  elseif ($type == 'node') {
    return TRUE;
  }

  return db_query($query, $id);
}

/**
 * Performs db queries required to hide an item.
 *
 * Inserts into hidden table.
 * Also if needed marks as seen in hidden_reported, unpublishes, stops comments on nodes.
 *
 * @param $nid
 *   int nid.
 * @param $cid
 *   int if hiding a comment, if node pass '0'.
 * @param $rid
 *   int id of reason for hiding (optional).
 * @param $public
 *   string html of public note (optional).
 * @param $private
 *   string html of private note (optional).
 * @param $filter
 *   int if called by filtering time to delay posting till, 0 for being done
 * @return
 *   FALSE on fail. hid on success.
 */
function hidden_hidden_hide($type, $id, $uid, $rid=0, $public='', $private='', $filter=FALSE) {
  // 'hide now' delay !=0 // in the future also editing a hidden if desired?
  // this check here to prevent just hidden, or calls from report as hidden etc. clashing

  if ($hidden = _hidden_hidden_get($type, $id)) {
    if ($hidden->delay==0) {
      drupal_set_message(t('The %type is already hidden!', array('%type' => $type)), 'error');
      return FALSE;
    }
    else {
      // OK to update existing delayed hide
      $hid = $hidden->hid;
      if ($type == 'node') {
        $query = "UPDATE {hidden_node} SET nid=%d, uid=%d, created=%d, rid=%d, publicnote='%s', privatenote='%s', delay=%d WHERE hid=%d";
        $result = db_query($query, $id, $uid, $created, $rid, $public, $private, $filter, $hid);
      }
      else {
        $query = "UPDATE {hidden_comment} SET cid=%d, uid=%d, created=%d, rid=%d, publicnote='%s', privatenote='%s', delay=%d WHERE hid=%d";
        $result = db_query($query, $id, $uid, $created, $rid, $public, $private, $filter, $hid);
      }
    }
  }
  else {
    // Insert into hidden table
    if ($type == 'node') {
      $query = "INSERT INTO {hidden_node} (nid, uid, created, rid, publicnote, privatenote, delay) VALUES (%d, %d, %d, %d, '%s', '%s', %d)";
      $result = db_query($query, $id, $uid, time(), $rid, $public, $private, $filter);
    }
    else {
      $query = "INSERT INTO {hidden_comment} (cid, uid, created, rid, publicnote, privatenote, delay) VALUES (%d, %d, %d, %d, '%s', '%s', %d)";
      $result = db_query($query, $id, $uid, time(), $rid, $public, $private, $filter);
    }
    $hid = db_last_insert_id("{hidden_$type}_hid", "hid");
  }
  if (! $result) {
    if ($filter === FALSE) {
      drupal_set_message(t('Database error while storing hidden.'), 'error');
    }
    _hidden_log(HIDDEN_LOG_DEBUG, "hidden_hidden_hide() failed to insert into {hidden_$type}", 'hidden', $hid);
    return FALSE;
  }

  if ($filter > 0) {
    // unpublishing handled by cron
    return TRUE;
  }

  $col = $type == 'node' ? 'nid' : 'cid';
  // If it has been reported mark as seen
  $reported = db_query("SELECT COUNT(*) FROM {hidden_reported_$type} WHERE $col=%d", $id);
  if (db_result($reported)>0) {
    if (! _hidden_reported_seen($type, $id, $uid)) {
      _hidden_log(HIDDEN_LOG_ERROR, t('Error marking as seen while hiding.'), 'hidden', $hid);
    }
  }

  if (! _hidden_hidden_hide_unpublish($type, $id)) {
    // It's a bit messy if something is in the hidden db but published
    // on display it checks published status before hidden bothing with hidden db
    return FALSE;
  }

  return TRUE;
}

/**
 * Unpublishes a node or comment
 *
 * Updates comments to status COMMENT_NOT_PUBLISHED
 * and nodes to status 0, and stops further comments
 *
 * @todo consider loading objects, manipulating (with actions), and saving
 *
 * @param $type
 *   string 'node' or 'comment'
 * @param $id
 *   int nid or cid
 * @return
 *   TRUE on success
 */
function _hidden_hidden_hide_unpublish($type, $id) {
  if ($type == 'comment') {
    // Set comment to unpublished
    if (! db_query('UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED ." WHERE cid=%d", $id)) {
      drupal_set_message(t("Database error occurred when updating comment's status."), 'error');
      _hidden_log(HIDDEN_LOG_DEBUG, 'hidden_hide_do() error unpublishing comment.', 'comment', $id);
      return FALSE;
    }
  }
  elseif ($type == 'node') {
    // set node to unpublished and comments to read-only
    if (! db_query("UPDATE {node} SET status = 0, comment = 1 WHERE nid = %d", $id)) {
      drupal_set_message(t("Database error occurred when updating node's status."), 'error');
      _hidden_log(HIDDEN_LOG_DEBUG, 'hidden_hide_do() error unpublishing node.', 'node', $id);
      return FALSE;
    }
  }
  else {
    // @todo error
    return FALSE;
  }

  return TRUE;
}

/**
 * Performs db queries required to unhide an item.
 *
 * @param $type
 *   string type 'node' or 'comment'.
 * @param $id
 *   int nid or cid.
 * @return
 *   bool TRUE on success.
 */
function _hidden_hidden_unhide($type, $id) {
  if ($type == 'comment') {
    $query = 'DELETE FROM {hidden_comment} WHERE cid = %d';
  }
  elseif ($type == 'node') {
    $query = 'DELETE FROM {hidden_node} WHERE nid = %d';
  }
  else {
    _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_hidden_unhide() called with invalid $type');
    return FALSE;
  }

  $result = db_query($query, $id);
  if (!$result) {
    drupal_set_message(t('Database error occurred when deleting item from hidden table.'), 'error');
    _hidden_log(HIDDEN_LOG_DEBUG, "_hidden_hidden_unhide() failed to delete from {hidden_$type}", $type, $id);
    return FALSE;
  }

  $result = _hidden_hidden_publish($type, $id);

  if ($result) {
    return TRUE;
  }
  else {
    _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_hidden_unhide() failed to publish.', $type, $id);
    return FALSE;
  }
}

/**
 * Opposite actions to _hidden_hidden_unpublish().
 *
 * @todo set comment status to correct for type, or back to previous settings (need storing).
 */
function _hidden_hidden_publish($type, $id) {
  if ($type == 'comment') {
    $result = db_query('UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d', $id);
  }
  else {
    // set comments to read/write
    $result = db_query('UPDATE {node} SET status = 1, comment = 2 WHERE nid = %d', $id);
  }

  return $result;
}

/**
 * Check parameters.
 *
 * @param $type
 *   string 'node' or 'comment'.
 * @param $id
 *   int nid or cid.
 * @return
 *   bool TRUE if pass, FALSE on fail
 */
function _hidden_check_param($type, $id) {
  if ($type != 'comment' && $type != 'node') {
    return FALSE;
  }
  // @todo $nid is a string from node_save(); should be is_int 
  if (! is_numeric($id) || $id < 1) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Marks reported posts as seen.
 *
 * @param $type
 *   string 'node' or 'comment'
 * @param $id
 *   int nid or cid
 * @param $uid
 *   int uid
 * @return
 *   FALSE on error
 */
function _hidden_reported_seen($type, $id, $uid) {
  if ($type == 'node') {
    $query = 'UPDATE {hidden_reported_node} SET seen=1, suid=%d WHERE nid=%d';
  }
  elseif ($type == 'comment') {
    $query = 'UPDATE {hidden_reported_comment} SET seen=1, suid=%d WHERE cid=%d';
  }
  else {
    return FALSE;
  }

  return db_query($query, $uid, $id);
}

/**
 * Records a reported item for hiding.
 *
 * @param $type
 *   string content 'comment' or 'node'.
 * @param $id
 *   int nid or cid
 * @param $uid
 *   int uid
 * @param $rid
 *   int rid reason id (optional).
 * @param $public
 *   string html of public note.
 * @param $private
 *   string html of private note.
 * @return
 *   FALSE on error
 */
function _hidden_reported_hide($type, $id, $uid, $rid=0, $public='', $private='') {
  if ($type == 'node') {
    $query = "INSERT INTO {hidden_reported_node} (nid, uid, created, rid, publicnote, privatenote) VALUES (%d, %d, %d, %d, '%s', '%s')";
    return db_query($query, $id, $uid, time(), $rid, $public, $private);
  }
  elseif ($type == 'comment') {
    $query = "INSERT INTO {hidden_reported_comment} (cid, uid, created, rid, publicnote, privatenote) VALUES (%d, %d, %d, %d, '%s', '%s')";
    return db_query($query, $id, $uid, time(), $rid, $public, $private);
  }

  return FALSE;
}

/********************************************************************
 * Hidden Reasons
 */

/**
 * Checks if a rid is a reason.
 *
 * @param $rid
 *   int reason id.
 * @return
 *   bool TRUE on reason id being valid.
 */
function hidden_reason_check($rid) {
  if (! $result = db_query('SELECT COUNT(*) FROM {hidden_reasons} WHERE rid=%d', $rid)) {
    _hidden_log(HIDDEN_LOG_DEBUG, 'hidden_reason_check() SELECT failed.', 'reason', $rid);
  }
  if (db_result($result) != 0) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Returns a hidden reason.
 *
 * Internally cached as view integration uses this rather than a join.
 *
 * @param $rid
 *   int reason id.
 * @param $only_enabled
 *   bool return only if enabled, default TRUE.
 * @param $cache
 *   bool use cached results, default TRUE.
 * @return
 *   object individual reason or FALSE.
 */
function hidden_reason_get($rid, $only_enabled = TRUE, $cache = TRUE) {
  return _hidden_reason_get($rid, $only_enabled, $cache);
}

/**
 * Returns array of all hidden reasons.
 *
 * @param $only_enabled
 *   bool return only enabled reasons, default TRUE.
 * @param $cache
 *   bool use cached results default TRUE.
 * @return
 *   object array of reason objects.
 */
function hidden_reason_get_all($only_enabled = TRUE, $cache = TRUE) {
  return _hidden_reason_get(-1, $only_enabled, $cache);
}

/**
 * Internal function to handle storing and returning reasons.
 *
 * Cached as used as a non-join table used by views.
 *
 * @param $rid
 *   int reason id (or -1 for all reasons).
 * @param $only_enabled
 *   bool only return enabled reasons.
 * @param $cache
 *   bool use cache.
 * @return
 *   array of reason object, an inidividual hidden object, FALSE
 */
function _hidden_reason_get($rid, $only_enabled, $cache) {
  static $reasons;

  if (! is_array($reasons) || ! $cache) {
    $query = 'SELECT * FROM {hidden_reasons}';
    if ($only_enabled) {
      $query .= ' WHERE enabled=1';
    }
    if (! $result = db_query($query)) {
      _hidden_log(HIDDEN_LOG_DEBUG, 'hidden_reason_get() SELECT failed', 'reason', $rid);
    }
    $reasons = array();
    while ($reason = db_fetch_object($result)) {
      $reasons[$reason->rid] = $reason;
    }
  }

  if ($rid > 0) {
    return isset($reasons[$rid]) ? $reasons[$rid] : FALSE;
  }
  else {
    return $reasons;
  }
}

// @todo all of these can go into hidden_reason_write() :-

/**
 * Update hidden reason.
 *
 * @param $title
 *   string plain text(255) title for hidden_reason.
 * @param $description
 *   string html text describing reason
 * @param $enabled
 *   bool TRUE for an enabled reason
 * @param $rid
 *   rid - reason id
 * @return
 *   FALSE fail, SAVED_* const for type of saved
 */
function hidden_reason_update($title, $description, $enabled, $rid) {
  if (hidden_reason_check($rid)) {
    if (! db_query("UPDATE {hidden_reasons} SET title='%s', description='%s', enabled=%d WHERE rid=%d", $title, $description, $enabled, $rid)) {
      _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_reasons_admin_form_submit() failed UPDATE.', 'reason', $rid);
      return FALSE;
    }
    return $rid;
  }
  else {
    _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_reasons_admin_form_submit() passed invalid $rid.', 'reason', $rid);
    return FALSE;
  }
}

/**
 * Create hidden reason
 *
 * @param $title
 *   string plain text(255) title for reason.
 * @param $description
 *   string html text description of reason.
 * @param $enabled
 *   bool TRUE for an enabled reason.
 */
function hidden_reason_create($title, $description, $enabled = TRUE) {
  if (! db_query("INSERT INTO {hidden_reasons} (title, description, enabled) VALUES ('%s', '%s', %d)", $title, $description, $enabled)) {
    _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_reasons_form_submit() failed INSERT.');
    return FALSE;
  }
  $rid = db_last_insert_id("{hidden_reasons}_rid", "rid");
  return $rid;
}

/**
 * Enable a reason.
 *
 * @param $rid
 *   rid
 * @return
 *   bool TRUE on success
 */
function hidden_reason_enable($rid) {
  if (! db_query('UPDATE {hidden_reasons} SET enabled=1 WHERE rid=%d', $rid)) {
    _hidden_log(HIDDEN_LOG_DEBUG, t('hidden_reason_enable failed enable reason'), $rid);
    return FALSE;
  }

  _hidden_log(HIDDEN_LOG_REASONS, t('Reason enabled.'), 'reason', $rid);
  return TRUE;
}

/**
 * Disable a reason
 *
 * @param $rid
 *   rid
 * @return 
 *   bool TRUE on success
 */
function hidden_reason_disable($rid) {
  if (! db_query('UPDATE {hidden_reasons} SET enabled=0 WHERE rid=%d', $rid)) {
    _hidden_log(HIDDEN_LOG_DEBUG, t('hidden_reason_disable failed'), $rid);
    return FALSE;
  }
  
  _hidden_log(HIDDEN_LOG_REASONS, t('Reason disabled.'), 'reason', $rid);
  return TRUE;
}

/**
 * Creates an (options) array of active hidden reasons.
 *
 * For hide form an options list of reason titles mapped to reason id.
 *
 * @return
 *   array options array
 */
function _hidden_reasons_get_options() {
  $reasons = hidden_reason_get_all();
  $options = array(0 => t('No standard reason'));
  foreach ($reasons as $rid => $reason ) {
    $options[$rid] = $reason->title;
  }

  return $options;
}

/********************************************************************
 * Filters
 */

/**
 * Send content to be checked against filters.
 *
 * Content will be hidden if it matches any filter.
 * The user will be notified if there is no delay on the filter.
 *
 * @param $content
 *   string content to run through filters
 * @param $type
 *   string 'node' or 'comment'
 * @param $id
 *   int nid or cid
 * @return
 *   bool TRUE on matching a filter
 */
function hidden_filter_content($content, $type, $id) {
  // @todo hidden content filter off-switch...

  if (($filter = _hidden_filter_content_test($content)) == FALSE) {
    _hidden_log(HIDDEN_LOG_DEBUG_FILTER, "hidden_filter_content() FALSE on $type $id");
    return FALSE;
  }

  _hidden_log(HIDDEN_LOG_DEBUG_FILTER, "hidden_filter_content() TRUE on nid $type $id");
  if ($filter->delay != 0) {
    $filter->delay += time();
  }
  else {
    drupal_set_message(t('Your post has been marked as possibly contravening the editorial policy, and will be hidden until a moderator can review it.'));
  }
  hidden_hidden_hide($type, $id, $filter->uid, $filter->rid, $filter->publicnote, $filter->privatenote, $filter->delay);
  return TRUE;
}

/**
 * Returns hidden filter
 *
 * @param $hfid
 *   int hidden filter id.
 * @return
 *   object hidden filter.
 */
function hidden_filter_load($hfid) {
  $query = 'SELECT f.hfid AS hfid, f.filter AS filter, f.type AS type, f.hits AS hits, f.lasthit AS lasthit, f.enabled AS enabled, f.weight AS weight,'
         .' r.title AS title, r.rid AS rid, r.publicnote AS publicnote, r.privatenote AS privatenote, r.uid AS uid, r.delay AS delay'
         .' FROM {hidden_filters} AS f'
         .' INNER JOIN {hidden_filter_reasons} AS r ON f.hfid = r.hfid'
         .' WHERE f.hfid = %d';
  $result = db_query($query, $hfid);
  return db_fetch_object($result);
}

/**
 * Deletes hidden filter
 *
 * @param $hfid
 *   int hidden filter id.
 * @return
 *   bool false on fail, true on success.
 */
function hidden_filter_delete($hfid) {
  $filter_result = db_query('DELETE FROM {hidden_filters} WHERE hfid = %d', $hfid);
  $reason_result = db_query('DELETE FROM {hidden_filter_reasons} WHERE hfid = %d', $hfid);
  return ((bool) $filter_result & (bool) $reason_result) ? TRUE : FALSE;
} 

/**
 * Create or update a hidden filter.
 *
 * $filter is passed by reference and will be filled as per drupal_write_record().
 *
 * @param $filter
 *   object filter to write (set hfid = 0 for new record).
 * @return
 *   FALSE, SAVED_NEW, SAVED_UPDATED.
 */
function hidden_filter_save(&$filter) {
  $filter_fields = drupal_schema_fields_sql('hidden_filters');
  $reason_fields = drupal_schema_fields_sql('hidden_filter_reasons');
  $save_fields = array_keys(get_object_vars($filter));
  $filter_result = $reason_result = FALSE;

  if (isset($filter_fields['hfid'])) {
    unset($filter_fields['hfid']);
  }

  if (isset($filter->hfid) && $filter->hfid > 0) {
    // an update 
    $update = array('hfid');
  }
  else {
    // an a new record
    $update = array();
    if (! count(array_intersect($reason_fields, $save_fields))) {
      // no accompanying reason information, need at least one field
      return FALSE;
    }
  }

  if (count(array_intersect($filter_fields, $save_fields))) {
    $filter_result = drupal_write_record('hidden_filters', $filter, $update);
    if (! $filter_result) {
      return FALSE;
    }
  }

  if (count(array_intersect($reason_fields, $save_fields))) {
    $reason_result = drupal_write_record('hidden_filter_reasons', $filter, $update);
    if (! $reason_result) {
      if ($filter_result == SAVED_NEW) {
        // prevent a filter without information being stored
        hidden_filter_delete($filter->hfid);
      }
      return FALSE;
    }
  }

  return $filter_result ? $filter_result : $reason_result;
}

/**
 * Enable or disable a filter.
 *
 * @param $hfid
 *  int hfid.
 * @param $enabled
 *  bool true to enable, false to disable.
 * @return
 *  SAVED_UPDATED or FALSE
 */
function hidden_filter_enable($hfid, $enabled = TRUE) {
  $filter = new StdClass;
  if ($hfid < 1) {
    return FALSE;
  }
  $filter->hfid = $hfid;
  $filter->enabled = $enabled;
  $result = hidden_filter_save($filter);
  if ($result == SAVED_NEW) {
    // we could have avoided this by loading and checking,
    //   but shouldn't really ever be called with invalid hfid.
    hidden_filter_delete($filter->hfid);
    return FALSE;
  }
  return $result;
}


/**
 * Returns all hidden filters pager query.
 *
 * Just a start at moving the queries out.
 *
 * @param $pager
 *   int pager_query pager id (optional).
 * @param $enabled
 *   int 0 only disabled filters, 1 only enabled filters (optional).
 */
function hidden_filter_all_get_pager($pager = 0, $enabled = -1) {
  $query = 'SELECT f.hfid as hfid, f.hits as hits, f.lasthit as date, f.weight as weight,'
         .' r.title'
         .' FROM {hidden_filters} AS f'
         .' INNER JOIN {hidden_filter_reasons} AS r ON f.hfid = r.hfid';
  if ($enabled == 0) {
    $query .= ' WHERE f.enabled=0';
  }
  elseif ($enabled == 1) {
    $query .= ' WHERE f.enabled=1';
  }
  $query .= ' ORDER BY f.weight DESC';
  $result = pager_query($query, 50, $pager);
  return $result;
} 

/**
 * Test a preg filter.
 *
 * @param $preg
 *   string expression to test.
 * @param $msg
 *   string to place error message into (optional).
 * @param
 *   bool FALSE on fail
 */
function _hidden_filter_preg_test($preg, &$msg = '') {
  $success = TRUE;
  $msg = '';
  $result = @preg_match($preg, 'foobar');

  if (version_compare(PHP_VERSION, '5.2.0') === 1) {
    switch (preg_last_error()) {
      case PREG_NO_ERROR:
        break;
      case PREG_INTERNAL_ERROR:
        $error = t('There was an internal PCRE error.');
        $success = FALSE;
        break;
      case PREG_BACKTRACK_LIMIT_ERROR:
        $error = t('backtrack_limit was exhasted.');
        $success = FALSE;
        break;
      case PREG_RECURSION_LIMIT_ERROR:
        $error = t('recursion_limit was exhasted.');
        $success = FALSE;
        break;
      case PREG_BAD_UTF8_ERROR:
        $error = t('malformed UTF-8 data.');
        $succes = FALSE;
        break;
    }
    if (! $success) {
      $msg = t('There was an error parsing the regular expression: %error', array('%error' => $error));
    }
  }
  else {
    $msg = t('There was an error parsing the regular expression.');
    $success = FALSE;
  }

  return $success;
}


/**
 * Test content against filters.
 *
 * @param $content
 *   string content to be tested.
 * @return
 *   mixed FALSE if it does not match filter object if matches
 */
function _hidden_filter_content_test($content) {
  $match = FALSE;

  $query = 'SELECT hfid, filter, type FROM {hidden_filters} WHERE enabled=1 ORDER BY weight ASC';
  $result = db_query($query);
  while ($filter = db_fetch_object($result)) {
    if ($filter->type == HIDDEN_FILTER_PLAIN && strpos($content, $filter->filter) !== FALSE) {
      $match =TRUE;
    }
    elseif ($filter->type == HIDDEN_FILTER_PREG && preg_match($filter->filter, $content) == 1) {
      $match = TRUE;
    }

    if ($match) {
      $filter = hidden_filter_load($filter->hfid);
      $filter->hits++;
      $filter->lasthit = time();
      hidden_filter_save($filter);
      return $filter;
    }
  }
  return FALSE;
}

/********************************************************************
 * Wrappers
 */

/**
 * watchdog() wrapper.
 *
 * @param $action
 *   from const HIDDEN_LOG_*.
 * @param $description
 *   string plain text description of action.
 * @param $type
 *   string 'node', 'comment', 'reason' if relevant.
 * @param $id
 *   int id or array of ids of node/comment/reason (optional).
 * @param $rid
 *   int rid of a hide/report (optional).
 * @param $public
 *   string description of reason for hide/report (optional).
 */
function _hidden_log($action, $description, $type='', $id=0, $rid=0, $public='', $uid='') {
  if ($uid=='') {
    global $user;
  }
  else {
    // only the case when called from a cron
    $user = user_load(array('uid' => $uid));
  }
  $items = array();
  $titles = '';
  // also called with $type='reason' $id=rid, but not being used presently

  if ($type=='comment' || $type=='node') {
    if (! is_array($id)) {
      $ids = array($id);
    }
    else {
      $ids = $id;
    }
    $titlea = array();
    foreach ($ids as $id) {
      if ($type=='comment') {
        $query = 'SELECT c.nid AS nid, c.cid AS cid, c.subject AS title,'
               .' u.uid AS uid, u.name AS name'
               .' FROM {comments} AS c'
               .' INNER JOIN {users} AS u ON c.uid=u.uid'
               .' WHERE c.cid = %d';
      }
      elseif ($type=='node') {
        $query = 'SELECT n.nid AS nid, n.title AS title,'
               .' u.uid AS uid, u.name AS name'
               .' FROM {node} AS n'
               .' INNER JOIN {users} AS u ON n.uid=u.uid'
               .' WHERE n.nid = %d';
      }
      $result = db_query($query, $id);
      $item = db_fetch_object($result);
      $items[] = $item;
      $titlea[] = $item->title;
    }
    $titles = format_plural(count($titlea), 'Title: ', 'Titles: ') . implode(', ', $titlea);
  }

  if ($action > 50) {
    $log = _hidden_settings_logging();
    if ($log[$action]['enabled']) {
      watchdog('hidden', $description .' '. $titles, array(), (($action == HIDDEN_LOG_DEBUG_FILTER) ? WATCHDOG_NOTICE : WATCHDOG_ERROR));
      //TODO deal with arrays and links
    }
    return;
  }

  $email = _hidden_settings_mail();
  if ($email['domail'] && $email['address'] != '' && $email[$action]['when'] != HIDDEN_MAIL_NEVER) {
    if ($email[$action]['when'] == HIDDEN_MAIL_LATER) {
      $query = "INSERT INTO {hidden_log} (hidetime, action, description, ids, uid) VALUES (%d, %d, '%s', '%s', %d)";
      if (! db_query($query, time(), $action, $description ."\n". $titles, serialize($items), $user->uid)) {
        watchdog('hidden', 'Error writing log to database',array() , WATCHDOG_ERROR);
      }
    }
    else {
      _hidden_mail( $description, _hidden_mail_message($action, $description ."\n". $titles, $user->name, $items, $rid, $public));
    }
  }
}

/**
 * Get additional information to run _hidden_mail_message() from cron with hidden_log parameters.
 */
function _hidden_mail_cron_message($action, $description, $items, $uid) {
  if (is_array($items)) {
    if ($action==HIDDEN_LOG_REPORTED || $action==HIDDEN_LOG_HIDE) {
      if ($action==HIDDEN_LOG_HIDE) {
        $table = 'hidden';
      }
      else {
        $table = 'hidden_reported';
      }
      // @todo this is borked there is no $cid; isset($items[0]->cid) maybe
      if ($cid==0) {
        $query = 'SELECT publicnote, rid from {'. $table .'_node} WHERE nid=%d';
        $id = $items[0]->nid;
      }
      else {
        $query = 'SELECT publicnote, rid from {'. $table .'_comment} WHERE cid=%d';
        $id = $items[0]->cid;
      }

      if ($result = db_query($query, $id)) {
        $item = db_fetch_object($result);
      }

      $rid = $item->rid;
      $public = $item->public;
    }
  }

  $user = user_load(array('uid' => $uid));

  return _hidden_mail_message($action, $description, $user->name, $items, $rid, $public);
}

/**
 * Constructs text for e-mail messages about actions.
 *
 * @param $action
 *   int from HIDDEN_LOG_ constants.
 * @param $description
 *   string description so far.
 * @param $user
 *   string user name.
 * @param $items
 *   array node/comment objects with nid, cid.
 * @param $rid
 *   int rid.
 * @param $public
 *   string public description.
 * @return
 *   string text of mail message.
 */
function _hidden_mail_message($action, $description, $user='anonymous', $items='', $rid='', $public='') {
  if ($user=='') {
    $user='anonymous';
  }
  $mail = sprintf("%s\nBy: %s\n", $description, $user);
  switch ($action) {
    case HIDDEN_LOG_HIDE:
    case HIDDEN_LOG_REPORTED:
      // add reason and public
      if ($reason = hidden_reason_get($rid)) {
        $mail .= sprintf("Reason: %s\n", $reason->title);
      }
      if ($public != '') {
        $mail .= sprintf("Note: %s\n", $public);
      }
    case HIDDEN_LOG_UNHIDE:
    case HIDDEN_LOG_SEEN:
    case HIDDEN_LOG_SPAM:
    // add links
      $links = array();
      foreach ($items as $item) {
        // @todo what's an item here we need $type, $id
        $mail .= _hidden_url($item->nid, $item->cid, TRUE, TRUE) ."\n";
      }
    case HIDDEN_LOG_REASONS:
    case HIDDEN_LOG_DELETE:
      // just send
  }
  return $mail;
}

/**
 * url() wrapper.
 *
 * @param $nid
 *   int nid.
 * @param $cid
 *   int cid.
 * @param $normal
 *   bool FALSE for hidden/ link TRUE for a node/ link.
 * @param $absolute
 *   bool TRUE for absolute link.
 * @return
 *   string text of url.
 */
 // @todo only called above
function _hidden_url($nid, $cid, $normal=FALSE, $absolute=FALSE) {
  if (! $normal) {
    if ($cid>0) {
      $path = "hidden/comment/$cid";
    }
    elseif ($nid>0) {
      $path = "hidden/node/$nid";
    }
    else {
      _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_url() called with invalid $nid or $cid');
      $path = '';
    }
  }
  else {
    if ($nid>0) {
      $path = "node/$nid";
      if ($cid>0) {
        $fragment = "comment-$cid";
      }
    }
    else {
      _hidden_log(HIDDEN_LOG_DEBUG, '_hidden_url() called with invalid $nid');
      $path = '';
    }
  }

  return url($path, array('fragment' => $fragment, 'absolute' => $absolute));
}

/**
 * drupal_mail() wrapper.
 *
 * sends content to e-mail address in settings.
 *
 * @param $subject
 *   string title for the e-mail.
 * @param $content
 *   string content of the e-mail.
 * @return
 *   bool TRUE on success.
 */
function _hidden_mail($subject, $content) {
  $email = _hidden_settings_mail();
  if ($email['address'] != '') {
    return drupal_mail('hidden_mail', $email['address'], $subject, wordwrap($content, 72), variable_get('site_mail', ini_get('sendmail_from')));
  }
  else {
    return FALSE;
  }
}

/**
 * Get a functioning path to be able to see content.
 *
 * Basic version to start, should be possible to let people override.
 * Should return a path that the present user will be able to view the
 * hidden content.
 *
 * @param $type
 *   string 'node' or 'comment'
 * @param $cid
 *   int nid or cid
 * @param $view
 *   string action 'view', 'hide', 'report'
 * @return array
 *   'path' => relative path, 'fragment' => if comment in a node view
 */
function hidden_path($type, $id, $action = 'view') {
  if (! _hidden_check_param($type, $id)) {
    return 'hidden';
  }

  switch ($action) {
    case 'view':
      return 'hidden/'. $type .'/'. $id;
    case 'hide':
      return 'hidden/'. $type .'/'. $id .'/hide';
    case 'report':
      return 'hidden/'. $type .'/'. $id .'/report';
  }
}

/**
 * variable_get('hidden_logging') or defaults.
 *
 * @return
 *   array present settings.
 */
function _hidden_settings_logging() {
  $defaults = array(
    HIDDEN_LOG_DEBUG_FILTER => array('enabled' => 1),
    HIDDEN_LOG_ERROR => array('enabled' => 1),
    HIDDEN_LOG_DEBUG => array('enabled' => 0),
  );
  return variable_get('hidden_logging', $defaults);
}

/**
 * variable_get('hidden_email') or defaults.
 *
 * @return
 *   array present settings.
 */
function _hidden_settings_mail() {
  $default = array(
    'domail' => FALSE,
    'address' => '',
    'frequency' => 864000,
    HIDDEN_LOG_HIDE => array('when' => HIDDEN_MAIL_NOW),
    HIDDEN_LOG_UNHIDE => array('when' => HIDDEN_MAIL_NOW),
    HIDDEN_LOG_REPORTED => array('when' => HIDDEN_MAIL_NOW),
    HIDDEN_LOG_SEEN => array('when' => HIDDEN_MAIL_LATER),
    HIDDEN_LOG_REASONS => array('when' => HIDDEN_MAIL_NEVER),
    HIDDEN_LOG_SPAM => array('when' => HIDDEN_MAIL_LATER),
    HIDDEN_LOG_DELETE => array('when' => HIDDEN_MAIL_NEVER),
  );
  return variable_get('hidden_email', $default);
}

/**
 * Find which node a comment is attached to.
 *
 * @param $cid
 *   int cid
 * @return
 *   int nid
 */
function _hidden_comment_nid($cid) {
  $comment = _comment_load($cid);
  return $comment->nid;
}
